早期页表模型：整个系统共享一个全局内核页表，所有进程的内核空间会直接映射物理内存，这样的问题是可以在用户态通过指针偏移直接访问内核空间
现在页表模型：per-process kernel page table，进程页表只包含“所需要的内核映射和用户映射”，上下文切换时需要切换页表。KPTI中每个进程包含两个页表，包含用户空间映射的用户页表，和完整内核映射+进程的用户空间映射的内核页表。用户态/内核态切换时会切换页表，但这样就会导致每次syscall都要刷新TLB产生开销。

x86页表结构：2^20 PTE数组。虚拟地址->PTE，高20位寻找其在页表中的索引，转换为PPN(physical page number)，低12位被硬件复制，所以一页的大小就是2^12 = 4k