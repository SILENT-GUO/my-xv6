### 早期页表模型
整个系统共享一个全局内核页表，所有进程的内核空间会直接映射物理内存，这样的问题是可以在用户态通过指针偏移直接访问内核空间
### 现在页表模型
per-process kernel page table，进程页表只包含“所需要的内核映射和用户映射”，上下文切换时需要切换页表。KPTI中每个进程包含两个页表，包含用户空间映射的用户页表，和完整内核映射+进程的用户空间映射的内核页表。用户态/内核态切换时会切换页表，但这样就会导致每次syscall都要刷新TLB产生开销。

## x86页表结构
2^20 PTE数组。虚拟地址->PTE，高20位寻找其在页表中的索引，转换为PPN(physical page number)，低12位被硬件复制，所以一页的大小就是2^12 = 4k，如果一个PTE的大小为4个字节，则一个页表页包含1024个PTE。
### 虚拟地址 -> PTE: 高位20位如何完成地址翻译
由于一般的页表是table of page table结构，因此一般是用高10位来从页表页中选择出对应的目录页，并用接下来的低10位来从目录页中选择出对应的PTE


